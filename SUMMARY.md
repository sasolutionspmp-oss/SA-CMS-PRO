SUMMARY SNAPSHOT — 2025-09-20T15:20Z (~330 words)

Documentation overhaul (Task 20) is committed and Tasks 19–18 now add the regression and tooling backbone for the reverse-order backlog push. On the backend side I introduced targeted pytest modules under `tests/unit/ingest/` and `tests/unit/metrics/` to lock down document parsing, classification, risk heuristics, and metrics normalisation. The parsing suite covers text/csv fallbacks, the PDF extraction hook, and snippet truncation logic; classifier tests validate the discipline, revision, and addendum detectors; risk flagger tests exercise a new `app/ingest/risk_flagger.py` utility that tags liquidated damages, bonding, no-substitution clauses, and extended warranties with line references. Metrics tests assert `normalize_metrics_payload` coerces project counts and sanitises deltas. All four test files run cleanly via `.venv\Scripts\python -m pytest tests/unit/ingest/test_parsing.py tests/unit/ingest/test_classifier.py tests/unit/ingest/test_risk_flagger.py tests/unit/metrics/test_metrics_normalizer.py`.

To support the new risk assertions I created `app/ingest/risk_flagger.py` with a dataclass-based API returning de-duplicated `RiskFlag` entries (code, message, line, snippet). The patterns currently cover our critical contract warnings and can be extended when Task 16 arrives. No other ingest code paths were touched.

On the frontend I wired Playwright into the toolchain (`@playwright/test`, `playwright.config.ts`, and scripts/test commands). The smoke scenario `tests/e2e/intake-workflow.spec.ts` presently focuses on verifying the client hits `/api/intake/launch` when an operator submits the intake form; the request is intercepted and fulfilled with stub data so the run stays hermetic. The test executes successfully with `pnpm run test` after installing the Chromium bundle through `pnpm exec playwright install chromium`. We can enrich the scenario later when the dashboard wiring (Tasks 4/5/17) is implemented.

Task 18 adds two developer utilities: `scripts/dev.ps1` starts the API (uvicorn), worker, and Vite dev server concurrently with log streaming and a `-DryRun` flag, while `scripts/seed.ps1` wraps `python -m apps.api.seed` and can optionally POST to `/api/intake/launch` once the stack is running (the script now surfaces exit codes so stale SQLite schemas can be purged before reseeding). Together they give operators a single-command workflow to bring the stack up locally and hydrate demo data.

Tracking artefacts are current: `TASKS.md` shows Tasks 18–20 marked off, and `PROGRESS.md` logs the pytest/Playwright runs, dev bootstrap dry run, and the initial seed attempt (with guidance for outdated databases). Next in the reverse sequence is Task 17 (frontend/backend integration), where we will swap the mock APIs in `frontend/src/api.ts` for real endpoints and drive the new tests against a live stack using these scripts.
